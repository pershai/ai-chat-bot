spring:
  application:
    name: ai-chat-bot-java
    version: 1.0.0
    url: https://softteco.com
  servlet:
    multipart:
      max-file-size: 10485760        # Max file size per upload
      max-request-size: 104857600    # Max total request size
      file-size-threshold: 2097152   # Size threshold after which files will be written to disk
  main:
    allow-bean-definition-overriding: true

#  jackson:
#    serialization:
#      write-dates-as-timestamps: false

  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      ttl: ${REDIS_TTL:10}

  # Database Configuration (Postgres)
  datasource:
    url: jdbc:postgresql://${POSTGRES_HOST:localhost}:${POSTGRES_PORT:5432}/${POSTGRES_DB:postgres}
    username: ${POSTGRES_USER:postgres}
    password: ${POSTGRES_PASSWORD:postgres}

  jpa:
    hibernate:
      ddl-auto: update
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect

  # Flyway
  flyway:
    enabled: true
    baseline-on-migrate: true

  redis:
    stream:
      dlq:
        key: "ingestion-dlq"
        group: "ingest_group"
      ingestion:
        key: "ingest_events"
        group: "ingest_group"
        consumer:
          prefix: "consumer-"
          poll-timeout-ms: 1000
          auto-startup: true

# LangChain4j configuration
langchain4j:
  gemini:
    chat-model:
      api-key: ${GOOGLE_API_KEY}
      model-name: ${LLM_MODEL_NAME}
      temperature: 0.7
      timeout: 60
      max-memory-size: 10
  embedding:
    provider: huggingface  # Options: huggingface, google, local
    huggingface:
      api-key: ${HUGGINGFACE_API_KEY:}
      model-name: ${EMBEDDING_MODEL}
      timeout: 30
    google:
      model-name: text-embedding-004
  qdrant:
   host: ${QDRANT_HOST:localhost}
   port: ${QDRANT_PORT:6334}
   collection-name: documents
   # api-key: ... if needed
  document:
    splitter:
      max-segment-size: 1000
      max-overlap-size: 200
      maxResults: 3
#Documentation
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    operationsSorter: method
  show-actuator: false

# Async uploading
async:
  ingestion:
    core-pool-size: 2
    max-pool-size: 4
    queue-capacity: 500
    thread-name-prefix: "ingest-"

# Logging
logging:
  level:
    org:
      springframework:
        web: INFO
    dev:
      langchain4j: DEBUG

app:
  error:
    include-stacktrace: never  # or "always" or "on-param"
    include-message: always
    include-binding-errors: always
    include-exception: false
  job:
    ttl:
      active-minutes: 120  # 2 hours for active/stuck jobs
      completed-minutes: 30  # 30 minutes for completed jobs
  jwt:
      expiration-ms: 86400000
      secret: ${JWT_SECRET_KEY}
  file-storage:
    allowed-extensions: pdf,doc,docx,txt
    max-filename-length: 255
    storage-path: ${FILE_STORAGE_PATH}

# LLM Guard
llm:
  guard:
    max-input-length: 10000  # characters
    log-violations: true

# Resilience4j
resilience4j:
  circuitbreaker:
    instances:
      gemini:
        registerHealthIndicator: true
        slidingWindowSize: 10
        permittedNumberOfCallsInHalfOpenState: 3
        slidingWindowType: COUNT_BASED
        minimumNumberOfCalls: 5
        waitDurationInOpenState: 5s
        failureRateThreshold: 50
        eventConsumerBufferSize: 10
  ratelimiter:
    instances:
      api:
        limitForPeriod: 100         # 100 requests
        limitRefreshPeriod: 60s     # per minute
        timeoutDuration: 0s         # Fail immediately if limit exceeded
      chat:
        limitForPeriod: 20          # 20 chat messages
        limitRefreshPeriod: 60s     # per minute
        timeoutDuration: 0s         # Fail immediately if limit exceeded

# Management / Actuator
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: when-authorized
      show-components: when-authorized
  metrics:
    tags:
      application: ${spring.application.name}
